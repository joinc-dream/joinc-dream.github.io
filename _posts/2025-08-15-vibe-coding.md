---
layout: single 
title: "Vibe 코딩 한달살이"
date: 2025-08-10 10:00:00 +0900
author: sangbaeyun 
categories: LLM 생성형-AI AI-코딩 Vibe-Coding 소프트웨어-엔지니어링 
card_description: "AI 코딩 어시스턴트를 넘어선 '바이브 코딩'의 개념과 Gemini CLI를 활용한 한 달간의 개발 경험을 공유합니다. AI 주도 개발의 실제와 미래를 탐색합니다."
gallery:
  - url: /assets/images/posts/2025/vibe-coding-02.png
    image_path: /assets/images/posts/2025/vibe-coding-02.png
    alt: "바이브-코딩 예제"
  - url: /assets/images/posts/2025/vibe-coding-03.png
    image_path: /assets/images/posts/2025/vibe-coding-03.png
    alt: "바이브-코딩 예제"
  - url: /assets/images/posts/2025/vibe-coding-04.png
    image_path: /assets/images/posts/2025/vibe-coding-04.png
    alt: "바이브-코딩 예제"
  - url: /assets/images/posts/2025/vibe-coding-05.png
    image_path: /assets/images/posts/2025/vibe-coding-05.png
    alt: "바이브-코딩 예제"
  - url: /assets/images/posts/2025/vibe-coding-06.png
    image_path: /assets/images/posts/2025/vibe-coding-06.png
    alt: "바이브-코딩 예제"
  - url: /assets/images/posts/2025/vibe-coding-07.png
    image_path: /assets/images/posts/2025/vibe-coding-07.png
    alt: "바이브-코딩 예제"
  - url: /assets/images/posts/2025/vibe-coding-08.png
    image_path: /assets/images/posts/2025/vibe-coding-08.png
    alt: "바이브-코딩 예제"

---
## AI 코딩 어시스턴트
**AI 어이스턴트**를 이용한 개발은 대략 2021년 이후 일상화된 것으로 알려져 있다. OpenAI Codex, GitHub Copilot 코딩 AI 어시스턴트의 시작을 알렸고, 그 이후 Cursor, Windsurf, Replit AI, Claude Code, Gemini CLI 등 여러 도구들이 실무에서 사용되기 시작했다. 이 때가 2021년이니 코딩에서 AI의 도움을 받기 시작한 건 꽤 오래됐다고 볼 수 있다.

| 시기            | 주요 특징                            | 대표 예시                            |
| --------------- | ------------------------------------ | ------------------------------------ |
| 1990년 이전     | 구문강조, 기초 자동완성              | 일반 IDE 기능                        |
| 2018년 경       | AI 기반 코드 자동완성 최초 등장      | Codota, Tabnine                      |
| 2021년          | 자연어 기반 코드 생성도구 시작       | OpenAI Codex, GitHub Copilot         |
| 2021년 이후     | AI 코딩 도구의 빠른 확산 및 다양화   | Cursor, Windsurf, Claude, Gemini CLI |

## Vibe Coding vs AI 코딩 어시스턴트
그런데 2025년 부터 **Vibe Coding** 이라는 개발 방법이 유행하고 있다. 바이브 코딩도 어차피 AI의 도움을 받아서 하는 건데 왜 갑자기 유행을 타기시작했는지, AI 코딩 도구의 도움을 받아서 개발하는 것과 어떤 차이가 있는건지 궁금해서 살펴보기로 했다. 

결론부터 말하자면 둘다 AI의 도움을 받아서 코드를 만드는 것이지만 "목적"과 "작업"방식에 중요한 차이가 있다. 먼저 바이브 코딩이 등장한 배경부터 살펴보겠습니다.

이 용어는 **Andrej Karpathy**가 2025년 2월에 처음 사용했으며, 이후 LLM에 기반한 개발혁신을 대표하는 개념으로 자리잡았습니다. 그는 "분위기에 몸을 맞긴다"라는 감성적인 표현으로 이 패러다임을 설명습니다. 흔한 개발자(테슬라에서 인공지능과 오토파일럿 비전 책임자로 일했으며 오픈 AI 공동창립자이니 흔한 개발자가 아니긴 합니다.) 가 그럴듯하게 지어낸 용어로 기억에서 지워질 수 있었지만 LLM과 관련 가장 성공한 개념이 되었습니다.

그 이유는 **실제 코딩 지식 없이도 작동하는 프로그램을 만든 사례** 들이 공유되면서 였습니다. 특히 **비 개발자들이 자연어만으로 아이디어를 구현했다는 사례**가 많은 주목을 받았습니다. 

{% include link-card.html url="https://medium.com/%40eperezarango1/vibe-coding-a-breakthrough-for-non-technical-builders-ready-to-build-the-next-wave-of-great-b20d92252ef9?utm_source=chatgpt.com" %}

바이브 코딩의 결정적인 차이는 기존 AI 코딩 어시스턴트가 "똑똑한 조수" 나 "네비게이션" 같았다면, 바이브 코딩은 AI를 "프로젝트를 이해하는 팀원"처럼 대하는 것에 있습니다.

| 구분           | 기존 AI 코딩 어시스턴트                           | 바이브 코딩                                      |
| -------------- | ------------------------------------------------- | ------------------------------------------------ |
| 역할           | 코드 자동완성, 스니펫 제안                        | 아이디어의 구체화, 기능단위의 개발               |
| 상호작용 수준  | 미시직: 이 함수의 다음 줄은 뭘까 ?                | 거시적: 로그인 페이지를 만들어줘                 |
| 개발자의 역할  | 윤전자: 개발자가 직접 코드를 작성하며 방향을 제시 | 지휘자: 개발자는 전체적인 방향과 의도를 전달     |
| 소통 방식      | 단일 코드라인, 함수, 작은 코드 블록               | 여러 파일에 걸친 변경, 전체 기능, 컴포넌트 단위  |
| 목표           | 반복작업 감소, 타이핑 속도 향상                   | 개발 사이클 단축, 프로토타이핑 가속화            |

요리로 비유해 보자면
 * 기존 AI 코딩 어시스턴트: 요리사가 요리 할 때, 재료를 다듬어 주거나 다음 레시피를 알려주는 **주방보조** 입니다. 요리의 주체는 여전히 요리사 입니다.
 * 바이브 코딩: 오늘의 스페셜 메뉴로 비프 웰링턴을 준비해.. 라고 지시하면 **수석 쉐프**가 조리 계획의 수립, 레시피 준비 부터 대부분의 조리 과정을 주도적으로 진행하는 것과 같습니다. 헤드 셰프는 중간 중간 맛을 보고 방향을 수정하고 최종 결과물을 책임집니다.

## 바이브 코딩 시작
바이브 코딩에 사용한 툴은 구글의 **Gemini CLI** 입니다. Gemini 2.5 pro와 Gemini 2.5 flash를 이용해서 코드를 도와주는 툴인데, CLI 라는 이름 처럼 터미널에서 대화를 통해서 코딩을 지시 할 수 있습니다. 그리고 작성한 코드를 직접 파일로 만들고, 빌드하고 테스트하는 작업 모두를 지시 할 수 있습니다. 

#### 기술적 백그라운드 
저의 기술적 백그라운드를 소개하겠습니다.
 * 25년차 개발자
 * 주요 언어: PHP, C, GoLang, Python
 * 검색엔진, 웹 애플리케이션 개발, DevOps 엔지니어, Cloud 엔지니어, 생성-AI 엔지니어
 * 전반적을 백앤드에 가깝습니다. 프론트앤드의 경우 PoC, 프로토타이핑을 할 수 있는 정도로 HTML, CSS, Javascript를 사용할 줄 아는 정도입니다. React.js 나 Vue.js 같은 현대적인 프레임워크의 사용 경험은 거의 없다 

#### 애플리케이션 소개
Chat 기능과 관리 기능을 가진 LLM Frontend 와 Frontend에 기능을 제공하는 API 서버를 개발했습니다.  

**LLM Frontend**
주요 기술셋으로 "Vue.js 3, Piana, TypeScript, Vite, Vitest, Bootstrap, markdown-it, vue-echart, axios"를 사용했습니다.

가장 중요한 목표는 "프로덕트에 내놓을 수 있는 수준의 애플리케이션을 개발"이었습니다.  
  * 컴포넌트 주도 아키텍처: UI를 독립적이고 재사용 가능한 컴포넌트로 나누어서 조립
  * 일관성 있는 프로젝트 구조: api, assets, components, composables, router, stores, style, utils, layout 등 공동작업자 누구나 파일의 위치와 역할을 쉽게 파악할 수 있는 예측 가능한 구조
  * 중앙 집중식 상태관리: Pinia를 이용 도메인 단위로 Store를 분리
  * API 로직 분리 및 추상화: 컴포넌트로 부터 API 호출을 분리하여 api 디렉토리에서 중앙 관리
  * 확장 가능한 라우팅 관리: 라우트 설정을 기능 단위로 분리
  * 코드 스타일과 컨벤션 통일: GEMINI.md 코드 스타일과 컨벤션을 명시하여서 지키도록 지시
  * Unit Test 및 E2E Test: 모든 컴포넌트와 개별함수에 대한 테스트
  * 환경변수 관리
  * 컨테이너 기반 빌드 환경, 빌드 스크립트 정의

**LLM Backend**
주요 기술셋으로 "fastapi, alembic, google-oauth2, langgraph, openai, pgvector" 등을 사용했습니다.

Frontend와 마찬가지로 가장 중요한 목표는 "프로덕트에 내놓을 수 있는 수준의 애플리케이션을 개발"이었습니다.  
  * 기능별 모듈화(Vertical Slicing): 관련된 API 라우터, 스키마(Pydantic 모델), 비즈니스 로직, 데이터베이스 모델을 하나의 기능단위로 묶어서 관리
  * 계층별 분리(Layerd Architecture): 각 모듈 내에서 역할의 명확한 분리
  * 의존성 주입을 통합 테스트 용이성 확보 및 결합도 감소
  * Pydantic를 통합 데이터 유효성 검사, Request Body와 Response Model 정의
  * API 문서 자동화
  * Unit Test
  * 코드 스타일과 컨벤션 통일: GEMINI.md 코드 스타일과 컨벤션을 명시하여서 지키도록 지시
  * 미들웨어를 이용한 공통관심사의 분리: 요청/응답 로깅, 에러처리, 인증/인가 확인, 데이터베이스 세션관리, HTTP 헤더 추가 및 검증

#### 중요하게 생각 한 것
제가 바이브 코드를 만들 때 어떤 것을 중요하게 생각하는지 눈치채셨을 겁니다. 저는 위의 원칙을 지키길 원했는데 왜냐하면 "바이브 코딩에 대한 환상을 버려야 한다"는 많은 사례들을 읽었기 때문입니다.   

  * 통제 가능한 복잡성: 바이브 코딩의 많은 성공 사례들이 **하나의 작업을 수행하는 몇 개의 컴포넌트로 구성된 소규모 애플리케이션** 들이었습니다.
  * 구조 필요성 최소화: 정교한 아키텍처나 디자인 패턴 없이도 구현 가능한 애플리케이션 이었습니다. 
  * 협업의 부재 또는 최소화: 1인 개발 프로젝트 혹은 소규모의 긴밀한 팀에서 만들 수 있는 결과물들이었습니다.
  * 프로토타입과 MVP에 최적화: 작 작동하는 결과물을 신속하게 만들 수 있다는 것에 목표를 두고 있는 애플리케이션이 많았습니다.

위의 조건을 벗어나는 순간 유지/보수 불가능한 코드를 만들어 낸다는 많은 사례를 접할 수 있었습니다. 이러한 생성형-AI 관련한 저의 경험과 일치하기도 했습니다. 따라서 저는 리스크와 실패를 줄이기 위해서 "평소 제가 했던 방식"으로 원칙, 구조를 만드는 것 부터 진행을 했습니다.

#### MCP 툴
LLM이 구조적으로 생각하도록 하기 위한 몇 가지 MCP 툴들도 사용하기로 했습니다. 수많은 툴들이 있던데 이 프로젝트에서는 2개의 툴만 이용했습니다.
  * **Context7**: AI 모델이 최신의 정보를 참고하여 정확한 코드를 생성하도록 돕는 실시간 문서 검색 도구입니다. AI 모델은 특징 시점까지의 데이터로 학습하기 때문에, 최신 라이브러리나 프레임워크의 변경사항을 알지 못합니다. 이 때문에 이미 사라진 함수나 예전 방식의 코드를 만들어내는 경우가 많은데, 이를 방지합니다. 
  * **Sequential-thinking**: AI가 논리적인 단계로 문제를 분해하고 계획을 세워서 순차적으로 해결하도록 유도하는 도구입니다. 

## 결과물
{% include gallery caption="FrontEnd 개발 결과물" %}

디자인 능력은 없는지라 [퍼플랙시티](https://www.perplexity.ai/) 의 디자인을 모방했습니다. 복잡하게 글로 설명하는 대신에, 퍼플랙시티 사이트를 스크린샷 뜬 다음, 스크린샷을 참조해서 레이아웃을 잡아달라고 지시했습니다. 화면에는 나오지 않지만 Fastapi 백앤드도 연동해서 기능을 만들었으며, 백앤드 API가 없는 경우 API 인터페이스를 가정해서 화면을 개발 했습니다. 
  1. API 명세서 개발: METHOD PATH, Request, Response 를 설계하고 문서화(Swagger, Postman Docs)
  2. API 모듈과 Mock 데이터 생성: 실제 API 호출을 담당할 모듈을 만든다. 백앤드 API 개발이 완료되기 전에는 axios 요청 대신 미리 만들어둔 Mock 데이터를 반환하도록 처리
  3. Pinia Store 구현: 상태관리를 위한 스토어를 만든다. 스토어 입장에서는 이 데이터가 실제 API에서 온 것인지 Mock 데이텅닌지 알 필요가 없습니다. 
  4. 컴포넌트 개발: Vue 컴포넌트는 Pinina 스토어의 액션을 호출하고 상태를 사용하면 됩니다. 
  5. 빌드/배포/테스트/문서확인을 위한 모든 툴들을 가지고 있습니다.

이 과정 모두를 Gemini CLI에 맡겼습니다. 직접 코드 수정은 하지 않고 사소한 수정 내용까지 100% AI 모델에 맡겼습니다. **하루 8시간씩 4일** 정도 작업을 진행했습니다.

## 회고
  1. AI 주도 개발을 하면서 겪는 대부분의 문제는 복잡성에서 비롯됩니다. 쪼개고 분해해서 해야 할 최사한의 기능을 개발하도록 지시하세요.
  1. 더 짧은 주기: 전통적인 개발 방법론은 2주 혹은 한달 단위의 긴 반복 주기를 가지고 있습니다. 이를 위한 스탠드업이나 스프린트 계획/회고와 같은 관행들이 생겨났습니다. AI의 경우 몇 시간 단위로 측정되는 훨씬 빠른 주기로 이어집니다. 짧은 코드를 만들고 실시간으로 검증 받고, 테스트하고 commit 하는 과정을 거쳐야 합니다. AWS에서는 스프린트 보다 더 짧은 주기를 볼트(Bolt)라고 부르고 있습니다.
  1. AI 주도 개발: AI 계획을 수립하고 이를 이끌어가가 합니다. 인간은 각 시점에 결정을 승인하고 옵션을 선택하고 확인하는 역할을 합니다. AI 주도 접근 방식이라고 할 수 있겠습니다. "AI 주도"라고 하면 반감을 가질 수 있는데, 인간이 부수적인 역할을 한다는 의미가 아닙니다. 개발자는 가치 높은 의사 결정에 집중을 하고 AI가 계획, 작업 분해 및 자동화를 처리한다는 의미입니다.
  1. 낙관적인? 미래: AI 의 개발 능력 향상에 대해서 저는 낙관적으로 봅니다. AI의 업무 해석 능력, 분해 능력은 점점 더 좋아질 것이고, AI를 다루는 사람의 능력도 점점 더 좋아질 겁니다. 그리고 AI와의 협업은 AI 주도 개발로 가야 잠재력을 발휘 할 수 있을 겁니다. AI가 보강 역할만하는 개발 방식으로는 AI가 주도 하는 개발 방식의 효과를 따라가기 어렵게 될 겁니다. 
  1. 소프트웨어 엔지니어링: 개발자는 방향을 설정하고 중요한 의사결정을 해야 하하며, 이를 위해서 도메인에 대한 지식 과 소프트웨어 엔지니어링에 대한 능력이 필요합니다. 개발을 이해하지 못한 상태에서 "정말 바이브"하게 만들어낼 수 있는 제품은 일반적인 제품이 아닙니다. 프로덕트의 90% 이상은 수많은 컴포넌트들의 조합으로 작동합니다. 개발자가 구조를 잡아주지 못한다면 소프트웨어는 빠르게 무너지게 될 겁니다. 
  1. 테스트 주도: AI 전에도 우리 개발자는 "테스트의 중요성"을 알고 있었습니다만 납기일 준수, 낮은 성숙도 등 여러 이유로 테스트를 제대로 수행하지 못했습니다. AI에 테스트를 맡김으로써 간단하게 테스트 주도 개발을 할 수 있습니다. AI 모델은 경험 많은 시니어가 아니라 "세상의 모든 코드를 읽어 본 열정 넘치는 주니어 개발자" 입니다. 그러다 보니 AI 모델은 과잉 해서 생각하는 경향이 있습니다. 미래에 필요할지 모르는 인터페이스, 추상 클래스, 서비스 레이어, 패턴 등 모두를 포함한 어떤 것을 제안하려고 합니다. 개발자가 가이드라인을 정해주지 않으면, 알 수 없는 혼종이 생겨나게 됩니다. 이러한 문제는 기능의 분해, (쓸데 없는 짓 하지 말라는) 프롬프트 작성 등의 방법을 통해서 완화할 수 있는데, 유닛 테스트는 가장 효과적인 방법입니다.
  1. 구조 개선 -> 코드 개선 -> 구조 개선 의 작업을 계속 해나가야 하며, 이 과정을 짧은 주기(Bolt)로 수행해야 합니다. 그리고 이 둘이 섞이면 안됩니다. 구조 개선 할때는 코드 개선을 하지 않아야 하고, 코드 개선 할 때는 구조 개선을 하지 않아야 합니다.
  1. 수석 요리사라고 생각하고 AI와 함께 학습을 해나가야 합니다. 특히 저 같이 세부 구현보다 시스템 구성에 관심을 가진 개발자는 이러한 작업이 매우 재미있을 겁니다.(저는 이러한 작업이 매우 즐겁습니다.) 
  1. AI 모델은 기억을 하지 못합니다. 그러니 작업 지시와 작업 내용을 마크다운 형태로 저장을 해둬야 합니다. 저 같은 경우 llm-docs 디렉토리 밑에 파일 형태로 저장하고 있습니다. 그리고 프롬프트를 통해서 llm-docs에 있는 문서를 기반으로 작업을 이어나가도록 지시합니다. 

결과는 매우 만족스러웠습니다. AI 모델의 지원이 없었다면, 결고 이루어낼 수 없는 일을 이루어냈기 때문입니다. 앞으로도 AI 모델을 계속 사용 할 것 같습니다. AI 모델을 사용하기 전이라면 "할 수는 있지만 너무 많은 시간이 걸려서 하지 않았던(혹은 못했던)" 그런 작업을 이제는 혼자 할 수 있게 되었습니다. 이 환경은 많은 기회를 가져다 줄 것입니다. 

## 프롬프트
처음에 작업 할 때는 "엄청나게 짜증"이 났습니다. 바이브 코딩 좀 해보시면 AI와 같이 일하는게 결코 바이브 하지 않다는 것을 알게 될겁니다. 수십번의 시행착오를 거치면서 AI 모델에게 숙지시켜야 할 프롬프트에 대한 나름대로의 노하우를 가지게 됐습니다. 

 * 당신은 경험 많은 소프트웨어 엔지니어 입니다. 작업을 수행하기 전에 계획을 세우고 계획의 각 단계에 대한 체크박스를 마크다운 파일에 작성해주세요.
 * 미안하다고 말하지 마세요. 문제를 해결하는데 집중하세요.
 * 중요한 결정을 스스로 내리지 마세요. 계획을 수립한 후 제 검토와 승인을 받아야 합니다.
 * 게획은 "한번에 하나씩" 수행해야 합니다.
 * 작업을 끝낼 때마다 check list를 완료한 것으로 표시하세요
 * 요구사항.md 파일의 사용자 스토리를 참조해서 작업을 합니다. 독립적으로 구축 할 수 있는 여러 유닛으로 사용자 스토리를 그룹화 해주세요.
 * 가장 간단한 방법으로, 추상화 없이, 불필요한 패턴 사용하지 말고 "oo" 기능을 개발해줘 
 * Unit Test를 진행합니다. Unit Test 할 시나리오 계획을 수립해 주세요.
 * 예외 사항에 대한 추가적인 Unit Test가 있는지 검토해 주세요.

## 바이브 소프트웨어 엔지니어링
['From 'Vibe Coding' to 'Vibe Software Engineering](https://armandomaynez.substack.com/p/from-vibe-coding-to-vibe-software?r=557fs)에서 설명하는 AI 협업 애플리케이션 개발과정을 정리하는 것으로 글을 마무리 하려합니다.

![바이브 소프트웨어 엔지니어링](https://docs.google.com/drawings/d/e/2PACX-1vS9g-_uVdtTcYnFIALtwyfl5H7D5qJNcA4K3qvW15IpyrZE-Wuy-J6SubPlKo_dUE4wNJuHoMHH_R1i/pub?w=960&h=720)
##### 1 단계: 기반 전략 수립(Foundation & Strategy)
코드를 작성하기 전에 프로텍트의 "무엇을(What)"과 "왜(Why)"를 명확히 정의하여 탄탄한 기반을 마련합니다.
  1. 프로젝트 아이디어
    *  모든 프로젝트의 시작점으로, 해결하고자 하는 문제나 구현하고 싶은 기능에 대한 최초의 구상입니다.
  1. PRFAQ 초안 작성
    * 본격적인 기획의 첫단계로, 아마존의 PRFAQ 방법론을 사용합니다. 인간이 아이디어의 핵심을 제공하면, AI가 고객에게 전달될 가상의 보도자료(PR)과 예상 질문/답변(FAQ)의 초안을 빠르게 생성합니다.
    * 역할: AI는 구조화된 문서의 초안을 신속하게 작성하고, 인간은 비즈니스 목표와 고객 가치에 맞게 내용을 검토하고 수정하며 전략적 방향을 설정합니다.
  1. 시스템 설계
    * PRFAQ를 통해 **무엇을 만들지** 가 정해지면, **어떻게 만들지**에 대한 기술적 청사진을 그립니다. 필요한 기술 스택, 데이터베이스 구조, 아키텍처 등을 정의 합니다.
    * 역할: 인간이 핵심 요구사항을 제시하면, AI 표준적인 설계 패턴이나 기술 옵션을 제안합니다. 인간은 이를 바탕으로 프로젝트에 가장 적합한 기술적 결정을 내립니다.
  1. 사용자 스토리 작성
    * 시스템 설계를 바탕으로 개발해야 할 기능들을 사용자 관점에서 구체적인 시나리오로 잘게 나눕니다.(예: 사용자는 이메일과 비밀번호로 로그인 할 수 있다.)
    * 역할: AI가 PRFAQ와 시스템 설계 문서를 분석하여 필요한 사용자 스토리 목록의 초안을 생성하면 인간은 우선순위를 정하고 누락된 부분을 보완합니다.

##### 2 단계: 병렬적 실행
**트랙 - A**
  1. 반복적 코딩 및 테스트
    * 유튜브에서 바이럴 마케팅하는 바이브코딩 처럼 한번에 모든 것을 만들려 하지 마세요. 잘게 나뉜 사용자 스토리 기반으로 기능 단위의 코드를 생성하고 즉시 테스트 합니다.
    * 역할: AI가 특정 기능에 대한 코드를 생성하면, 인간은 그 코드를 즉시 테스트하고, 버그를 수정하면서 전체 시스템에 통합하는 역할을 반복합니다.
  1. UI/UX 통합
    * 작동하는 백앤드 코드에 사용자 UI/UX를 결합하여 실제 사용자가 조작할 수 있는 형태로 만듭니다.

**트랙 - B**
  1. 마케팅 및 브랜딩 계획
    * 개발과 동시에 제품의 정체성을 확립합니다. AI를 활용하여 타겟 고객, 시장 포지셔닝, 핵심 메시지, 톤앤매너 등을 포함한 마케팅 계획 초안을 만듭니다.
  1. 비주얼 스타일 가이드 제작
    * 앱의 로고, 색상 팔레트, 폰트 등 시각적 정체성을 정의합니다. AI에게 다양한 디자인 컨셉 생성을 요청하고 인간이 최종 방향을 선택하여 가이드를 완성합니다. 

##### 3 단계: 통합 및 출시 
  1. 최종 통합
     * 개발 트랙에서 완성된 기능적 애플리케이션과 브랜딩 트랙에서 정의된 시각적/언어적 요소들을 하나로 합쳐 완전한 제품을 만듭니다.
  1. 애플리케이션 출시
     * 모든 통합과 테스트가 완료된 최종 결과물을 시장에 출시합니다.